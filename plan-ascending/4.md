# Phase 4: CLI & Daemon

## CLI Structure

- [ ] Create `crates/cli/Cargo.toml`
  - [ ] Dependencies: clap, tokio, tracing, tracing-subscriber, indicatif, owo-colors
  - [ ] Add all seer-* crates as workspace dependencies
  - [ ] Binary target: `[[bin]] name = "snap"`

- [ ] Implement `main.rs`: CLI entry point
  ```rust
  use clap::{Parser, Subcommand};

  #[derive(Parser)]
  #[command(name = "snap")]
  #[command(about = "Repository checkpoint system")]
  struct Cli {
      #[command(subcommand)]
      command: Commands,
  }

  #[derive(Subcommand)]
  enum Commands {
      Init,
      Status,
      Log { /* args */ },
      Diff { /* args */ },
      Restore { /* args */ },
      Pin { /* args */ },
      Unpin { /* args */ },
      Gc,
      Publish { /* args */ },
      Push,
      Pull,
      Start,   // Start daemon
      Stop,    // Stop daemon
  }
  ```

- [ ] Implement main function
  - [ ] Initialize tracing subscriber
  - [ ] Parse CLI arguments
  - [ ] Dispatch to command handlers
  - [ ] Handle errors gracefully (user-friendly messages)

## Command: `tl init`

- [ ] Implement `cmd/init.rs`
  - [ ] `pub async fn run() -> Result<()>`
    ```rust
    // 1. Check if already initialized (.tl/ exists)
    // 2. Create .tl/ directory structure
    // 3. Initialize store (Store::init())
    // 4. Create initial checkpoint (empty tree)
    // 5. Optionally start daemon
    // 6. Print success message with next steps
    ```

- [ ] Create `.tl/config.toml` with defaults
  ```toml
  [retention]
  dense_count = 2000
  dense_window = "24h"

  [watcher]
  debounce_duration = "300ms"
  batch_size = 100
  buffer_size = 8192

  [daemon]
  auto_start = false
  ```

- [ ] Initialize empty tree checkpoint
  - [ ] Root tree: empty (no entries)
  - [ ] Reason: `Manual`
  - [ ] Set as HEAD

## Command: `tl status`

- [ ] Implement `cmd/status.rs`
  - [ ] `pub async fn run() -> Result<()>`
    ```rust
    // 1. Check daemon status (running/stopped)
    // 2. Read HEAD checkpoint
    // 3. Read journal stats (total checkpoints, size)
    // 4. Read store stats (total blobs, trees, disk usage)
    // 5. Display formatted output
    ```

- [ ] Display format
  ```
  Daemon: running (PID 12345)
  HEAD: 01HQZX... (2 minutes ago)
  Checkpoints: 1,234 (last 24h: 456)
  Store size: 45.2 MB (123 blobs, 567 trees)
  ```

- [ ] Use `owo-colors` for colored output
  - [ ] Green: daemon running
  - [ ] Red: daemon stopped
  - [ ] Yellow: warnings (if any)

## Command: `tl log`

- [ ] Implement `cmd/log.rs`
  - [ ] `pub async fn run(limit: usize, since: Option<String>) -> Result<()>`
    ```rust
    // 1. Load journal
    // 2. Query checkpoints (last N or since timestamp)
    // 3. For each checkpoint:
    //    - Load tree and compute diff summary
    //    - Display: ID, time, reason, files changed
    ```

- [ ] Display format
  ```
  01HQZX... 2 minutes ago  [fs_batch]  3 files changed
    M  src/main.rs
    A  src/new.rs
    D  src/old.rs

  01HQZY... 5 minutes ago  [manual]    1 file changed
    M  README.md
  ```

- [ ] Implement diff summary
  - [ ] Compare checkpoint tree with parent tree
  - [ ] `TreeDiff { added, removed, modified }`
  - [ ] Use symbols: `A` = added, `D` = deleted, `M` = modified

- [ ] Add filtering options
  - [ ] `--limit N`: show last N checkpoints (default: 20)
  - [ ] `--since <time>`: show checkpoints since timestamp
  - [ ] `--path <path>`: show only checkpoints touching path

## Command: `tl diff`

- [ ] Implement `cmd/diff.rs`
  - [ ] `pub async fn run(a: String, b: String) -> Result<()>`
    ```rust
    // 1. Parse checkpoint IDs (a, b)
    // 2. Load trees for both checkpoints
    // 3. Compute tree diff
    // 4. Display diff (unified diff format)
    ```

- [ ] Support diff targets
  - [ ] Checkpoint ID: `01HQZX...`
  - [ ] Named pin: `last-good`
  - [ ] Relative: `HEAD~3`
  - [ ] Time: `@1h` (1 hour ago)

- [ ] Display unified diff
  - [ ] For each changed file:
    ```
    diff --snap a/src/main.rs b/src/main.rs
    --- a/src/main.rs  (01HQZX...)
    +++ b/src/main.rs  (01HQZY...)
    @@ -10,3 +10,4 @@
     fn main() {
    -    println!("old");
    +    println!("new");
    +    println!("added");
     }
    ```

- [ ] Diff algorithm
  - [ ] Load blob contents for both versions
  - [ ] Use `similar` crate for text diff
  - [ ] Binary files: show size change only

## Command: `tl restore`

- [ ] Implement `cmd/restore.rs`
  - [ ] `pub async fn run(target: String, force: bool) -> Result<()>`
    ```rust
    // 1. Parse target checkpoint
    // 2. Confirm with user (unless --force)
    // 3. Load target tree
    // 4. Apply tree to working directory:
    //    - Delete files not in tree
    //    - Restore files from blobs
    //    - Set file modes correctly
    // 5. Create "restore" checkpoint (record this action)
    // 6. Update HEAD
    ```

- [ ] Implement working tree update
  - [ ] `restore_tree(tree: &Tree, repo_root: &Path) -> Result<()>`
    ```rust
    // For each entry in tree:
    //   - Read blob from store
    //   - Write to working directory
    //   - Set mode (permissions, executable bit)
    //   - Handle symlinks
    // For files in working dir not in tree:
    //   - Delete (with confirmation or --force)
    ```

- [ ] Safety checks
  - [ ] Warn if uncommitted changes exist
  - [ ] Require `--force` to overwrite local changes
  - [ ] Never touch `.tl/` or `.git/`

- [ ] Progress indicator
  - [ ] Use `indicatif` for progress bar
  - [ ] Show: `Restoring files... [====>    ] 1234/5678`

## Command: `tl pin` / `tl unpin`

- [ ] Implement `cmd/pin.rs`
  - [ ] `pub async fn pin(id: String, name: String) -> Result<()>`
    ```rust
    // 1. Parse checkpoint ID
    // 2. Verify checkpoint exists
    // 3. Create pin file: .tl/refs/pins/<name>
    // 4. Write checkpoint ID to file
    ```
  - [ ] `pub async fn unpin(name: String) -> Result<()>`
    ```rust
    // 1. Delete .tl/refs/pins/<name>
    ```
  - [ ] `pub async fn list_pins() -> Result<()>`
    ```rust
    // 1. List all files in .tl/refs/pins/
    // 2. Display: name, checkpoint ID, creation time
    ```

- [ ] Built-in pins (auto-created)
  - [ ] `last-good`: updated manually by user
  - [ ] `pre-push`: created before `tl push`

## Command: `tl gc`

- [ ] Implement `cmd/gc.rs`
  - [ ] `pub async fn run(dry_run: bool) -> Result<()>`
    ```rust
    // 1. Acquire GC lock (.tl/locks/gc.lock)
    // 2. Run GC algorithm (from journal)
    // 3. Display stats: checkpoints removed, space freed
    // 4. If --dry-run: show what would be deleted
    ```

- [ ] Display format
  ```
  GC completed:
    Checkpoints removed: 234
    Blobs deleted: 567
    Trees deleted: 123
    Space freed: 12.3 MB
  ```

- [ ] Progress indicator
  - [ ] Show phases: "Marking live objects...", "Sweeping dead objects..."

## Daemon Management

- [ ] Implement `daemon.rs`: Background watcher daemon
  ```rust
  pub struct Daemon {
      store: Arc<Store>,
      journal: Arc<Journal>,
      watcher: Watcher,
      updater: IncrementalUpdater,
      shutdown_rx: Receiver<()>,
  }
  ```

- [ ] Implement daemon lifecycle
  - [ ] `start() -> Result<()>`
    ```rust
    // 1. Check if daemon already running (check .tl/locks/daemon.lock)
    // 2. Write PID to daemon.lock
    // 3. Initialize store, journal, watcher
    // 4. Start watcher loop
    // 5. Start IPC server (Unix socket)
    // 6. Handle shutdown signals (SIGTERM, SIGINT)
    ```

  - [ ] `stop() -> Result<()>`
    ```rust
    // 1. Send shutdown signal to daemon
    // 2. Wait for graceful shutdown (timeout: 5s)
    // 3. Remove daemon.lock
    ```

- [ ] Implement daemon main loop
  - [ ] `run_loop()`
    ```rust
    loop {
        select! {
            batch = watcher.next_batch() => {
                // Process batch of changed paths
                create_checkpoint(batch).await?;
            }
            req = ipc.next_request() => {
                // Handle IPC request from CLI
                handle_ipc(req).await?;
            }
            _ = shutdown_rx.recv() => {
                break;  // Graceful shutdown
            }
        }
    }
    ```

- [ ] Implement checkpoint creation in daemon
  - [ ] Debounced: accumulate changes, create checkpoint periodically
  - [ ] Incremental: use IncrementalUpdater
  - [ ] Non-blocking: checkpoint creation should be fast (< 10ms)

## IPC Communication

- [ ] Implement `ipc.rs`: Daemon communication
  ```rust
  pub struct IpcServer {
      socket: UnixListener,
  }

  pub enum IpcRequest {
      GetStatus,
      GetHead,
      GetCheckpoint(CheckpointId),
      Shutdown,
  }

  pub enum IpcResponse {
      Status(DaemonStatus),
      Head(Checkpoint),
      Checkpoint(Option<Checkpoint>),
      Ok,
  }
  ```

- [ ] Unix socket location: `.tl/state/daemon.sock`

- [ ] Implement request/response protocol
  - [ ] Use serde + bincode for serialization
  - [ ] Simple framed protocol: `[length: u32][payload: bytes]`

- [ ] CLI uses IPC to query daemon
  - [ ] `tl status` → `GetStatus` request
  - [ ] `tl log` → query journal directly (no IPC needed)
  - [ ] `tl stop` → `Shutdown` request

## Daemon Lock Management

- [ ] Implement `locks.rs`: Lock file handling
  ```rust
  pub struct DaemonLock {
      path: PathBuf,
      file: File,
  }
  ```

- [ ] `acquire() -> Result<DaemonLock>`
  - [ ] Try to acquire exclusive lock (flock)
  - [ ] If locked: read PID, check if process alive
  - [ ] If process dead: remove stale lock, retry
  - [ ] If process alive: return error "daemon already running"

- [ ] `release()`
  - [ ] Remove lock file
  - [ ] Release flock

- [ ] Stale lock detection
  - [ ] Read PID from lock file
  - [ ] Check `/proc/<pid>` (Linux) or `kill -0 <pid>` (macOS)
  - [ ] If process not found: lock is stale

## Command: `tl start` / `tl stop`

- [ ] Implement `cmd/start.rs`
  - [ ] `pub async fn run(foreground: bool) -> Result<()>`
    ```rust
    if foreground {
        // Run daemon in foreground (for debugging)
        daemon::start_foreground().await?;
    } else {
        // Fork daemon to background
        daemon::start_background().await?;
    }
    ```

- [ ] Implement background daemon spawn
  - [ ] Use `daemonize` crate (optional)
  - [ ] Or: `nohup snap start --foreground &`
  - [ ] Redirect stdout/stderr to `.tl/logs/daemon.log`

- [ ] Implement `cmd/stop.rs`
  - [ ] Send `Shutdown` IPC request
  - [ ] Wait for daemon to exit (poll lock file)
  - [ ] Timeout after 5 seconds (force kill if needed)

## Auto-start Integration (Optional for MVP)

- [ ] macOS: LaunchAgent
  - [ ] Generate `~/Library/LaunchAgents/com.snap.daemon.plist`
  - [ ] `launchctl load/unload`

- [ ] Linux: systemd user service
  - [ ] Generate `~/.config/systemd/user/snap-daemon.service`
  - [ ] `systemctl --user enable/disable snap-daemon`

- [ ] **Decision**: Manual start for MVP
  - [ ] User runs `tl start` explicitly
  - [ ] Auto-start is optional enhancement

## Logging & Metrics

- [ ] Implement structured logging
  - [ ] Use `tracing` for all log output
  - [ ] Levels: ERROR, WARN, INFO, DEBUG, TRACE
  - [ ] Format: `[timestamp] [level] [target] message`

- [ ] Daemon logs to `.tl/logs/daemon.log`
  - [ ] Rotate logs (keep last 5 files, max 10MB each)
  - [ ] Log: checkpoint creation, errors, watcher events

- [ ] CLI logs to stderr (colorized)
  - [ ] User-facing messages (not debug logs)

- [ ] Metrics collection
  - [ ] Write to `.tl/state/metrics.json`
  - [ ] Track: checkpoints/hour, bytes written, errors
  - [ ] Use for `tl status` display

## Testing

- [ ] Unit tests for CLI parsing
  - [ ] Test all commands parse correctly
  - [ ] Test argument validation

- [ ] Integration tests for daemon
  - [ ] Start daemon, verify it's running
  - [ ] Stop daemon, verify clean shutdown
  - [ ] Test IPC communication

- [ ] Integration tests for restore
  - [ ] Create checkpoint, modify files, restore
  - [ ] Verify working tree matches checkpoint exactly

- [ ] End-to-end test
  - [ ] `tl init` → `tl start` → make changes → `tl log` → `tl restore`

## Memory Optimization

- [ ] CLI: Minimal startup overhead
  - [ ] Lazy load: only load components for active command
  - [ ] Target: < 50ms startup time

- [ ] Daemon: Long-lived process optimization
  - [ ] No per-checkpoint allocation (reuse buffers)
  - [ ] Target: < 40MB resident (includes watcher + journal + store)

## User Experience Polish

- [ ] Error messages
  - [ ] User-friendly errors (not raw Rust backtraces)
  - [ ] Suggestions: "Did you mean `tl init`?"

- [ ] Progress indicators
  - [ ] Use `indicatif` for long operations (restore, GC)
  - [ ] Show: current file, percentage, ETA

- [ ] Colors and formatting
  - [ ] Use `owo-colors` for terminal colors
  - [ ] Consistent formatting across commands
