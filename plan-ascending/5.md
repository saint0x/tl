# Phase 5: JJ Integration

## Overview

**Design principle**: JJ is the **publication layer**, not the source of truth.
- Checkpoints are high-frequency (every file save)
- JJ commits are low-frequency (explicit publish)
- No automatic JJ commit on every checkpoint

## JJ Bridge Structure

- [ ] Create `crates/jj/Cargo.toml`
  - [ ] Dependencies: jj-lib, tempfile, tokio
  - [ ] Add all seer-* crates as workspace dependencies

- [ ] Implement `lib.rs`: JJ bridge interface
  ```rust
  pub struct JjBridge {
      store: Arc<Store>,
      journal: Arc<Journal>,
      jj_workspace: PathBuf,  // Path to .jj/ (if exists)
  }
  ```

- [ ] Initialize JJ workspace detection
  - [ ] `detect_jj_workspace(repo_root: &Path) -> Option<PathBuf>`
    - [ ] Check if `.jj/` directory exists
    - [ ] Verify it's a valid JJ workspace
    - [ ] Return path to workspace

- [ ] JJ is **optional** for MVP
  - [ ] If no `.jj/` found: JJ commands are disabled
  - [ ] User must run `jj git init` separately (we don't init JJ)

## Checkpoint → JJ Commit Materialization

- [ ] Implement `materialize.rs`: Convert checkpoint to JJ commit
  ```rust
  pub async fn materialize_commit(
      &self,
      checkpoint_id: CheckpointId,
  ) -> Result<jj_lib::backend::CommitId>
  ```

- [ ] Materialization algorithm
  ```rust
  // 1. Load checkpoint from journal
  let checkpoint = journal.get_by_id(checkpoint_id)?;

  // 2. Load tree from store
  let tree = store.read_tree(checkpoint.root_tree)?;

  // 3. Create temporary working copy
  let temp_dir = tempfile::tempdir()?;

  // 4. Restore tree to temp directory
  for (path, entry) in tree.entries {
      let blob = store.read_blob(entry.blob_hash)?;
      write_file(temp_dir.join(path), &blob)?;
      set_mode(temp_dir.join(path), entry.mode)?;
  }

  // 5. Import into JJ as commit
  let commit_id = jj_lib::commit::import_tree(
      jj_workspace,
      temp_dir.path(),
      parent_commit_id,
  )?;

  // 6. Set commit metadata
  jj_lib::commit::set_message(commit_id, format_commit_message(&checkpoint))?;
  jj_lib::commit::set_timestamp(commit_id, checkpoint.meta.timestamp)?;

  // 7. Clean up temp directory
  temp_dir.close()?;

  Ok(commit_id)
  ```

- [ ] Commit message formatting
  - [ ] `format_commit_message(checkpoint: &Checkpoint) -> String`
    ```rust
    let mut msg = String::new();
    msg.push_str(&format!("Checkpoint {}\n\n", checkpoint.id));

    // Add summary of changes
    for path in &checkpoint.touched_paths {
        msg.push_str(&format!("  - {}\n", path.display()));
    }

    // Add metadata
    msg.push_str(&format!("\nReason: {:?}\n", checkpoint.meta.reason));
    msg.push_str(&format!("Files changed: {}\n", checkpoint.meta.stats.files_changed));

    msg
    ```

## Command: `tl publish`

- [ ] Implement `cmd/publish.rs` in cli
  - [ ] `pub async fn run(target: String, bookmark: Option<String>) -> Result<()>`
    ```rust
    // 1. Parse target checkpoint (ID, pin, or range)
    // 2. Verify JJ workspace exists
    // 3. Load checkpoint(s)
    // 4. Materialize as JJ commit(s)
    // 5. Create bookmark (if specified)
    // 6. Pin checkpoint as "pre-push"
    ```

- [ ] Support publish targets
  - [ ] Single checkpoint: `tl publish HEAD`
  - [ ] Range: `tl publish HEAD~10..HEAD` (create 10 JJ commits)
  - [ ] Named pin: `tl publish last-good`

- [ ] Bookmark naming
  - [ ] Default: `snap/<checkpoint-id>`
  - [ ] Custom: `tl publish HEAD -b my-feature`
  - [ ] Bookmark points to JJ commit (for `jj git push`)

- [ ] Create "pre-push" pin
  - [ ] Before materializing: pin checkpoint as `pre-push`
  - [ ] Prevents GC of published checkpoint
  - [ ] User can always restore to pre-push state

## Checkpoint Range Compaction

- [ ] Implement range handling
  - [ ] `publish_range(start: CheckpointId, end: CheckpointId) -> Result<()>`
    ```rust
    // Option 1: Create one JJ commit per checkpoint (verbose)
    for cp_id in journal.range(start, end)? {
        materialize_commit(cp_id).await?;
    }

    // Option 2 (MVP): Compact range into single JJ commit
    // Materialize only the end checkpoint (skip intermediate)
    materialize_commit(end).await?;
    ```

- [ ] **MVP decision**: Compact to single commit
  - [ ] Publish `HEAD~10..HEAD` → 1 JJ commit (end state)
  - [ ] Intermediate checkpoints stay in seer (fine-grained history)
  - [ ] JJ gets coarse-grained publication history

- [ ] Future enhancement: One commit per checkpoint
  - [ ] User flag: `--expand` to create commit per checkpoint
  - [ ] Useful for detailed Git history

## Command: `tl push`

- [ ] Implement `cmd/push.rs` in cli
  - [ ] `pub async fn run(bookmark: Option<String>) -> Result<()>`
    ```rust
    // 1. Verify JJ workspace exists
    // 2. Determine bookmark to push (default: current)
    // 3. Call `jj git push -b <bookmark>`
    // 4. Handle push errors (authentication, conflicts)
    ```

- [ ] Delegate to JJ
  - [ ] Use `jj-lib` to execute push
  - [ ] Or: shell out to `jj` CLI (simpler for MVP)
    ```rust
    std::process::Command::new("jj")
        .args(&["git", "push", "-b", bookmark])
        .status()?;
    ```

- [ ] Pre-push checkpoint
  - [ ] Before push: create checkpoint (if changes exist)
  - [ ] Pin as `pre-push`
  - [ ] If push fails: user can restore to pre-push

## Command: `tl pull`

- [ ] Implement `cmd/pull.rs` in cli
  - [ ] `pub async fn run() -> Result<()>`
    ```rust
    // 1. Call `jj git fetch`
    // 2. Optionally: `jj rebase` (user's choice)
    // 3. Import pulled commits as pinned checkpoints
    ```

- [ ] Import JJ commits to seer
  - [ ] `import_jj_commit(commit_id: jj_lib::backend::CommitId) -> Result<CheckpointId>`
    ```rust
    // 1. Export JJ commit tree to temp directory
    let temp_dir = tempfile::tempdir()?;
    jj_lib::commit::export_tree(commit_id, temp_dir.path())?;

    // 2. Create seer tree from working copy
    let tree = tree_from_directory(temp_dir.path())?;
    let tree_hash = store.write_tree(&tree)?;

    // 3. Create checkpoint
    let checkpoint = Checkpoint {
        id: Ulid::new(),
        parent: current_head,
        root_tree: tree_hash,
        touched_paths: vec![],  // Unknown (full snapshot)
        meta: CheckpointMeta {
            timestamp: jj_lib::commit::get_timestamp(commit_id)?,
            reason: CheckpointReason::Publish,
            size_delta: 0,
            stats: Default::default(),
        },
    };
    journal.append(checkpoint)?;

    // 4. Pin as baseline
    pin(checkpoint.id, "pulled-baseline")?;

    Ok(checkpoint.id)
    ```

- [ ] **MVP decision**: Manual import
  - [ ] Don't auto-import all JJ commits
  - [ ] User runs `tl pull --import` to create checkpoint from JJ head
  - [ ] Keeps checkpoint count manageable

## JJ ↔ Seer Mapping

- [ ] Implement `mapping.rs`: Track checkpoint ↔ JJ commit links
  ```rust
  pub struct Mapping {
      db: sled::Tree,  // checkpoint_id -> jj_commit_id
  }
  ```

- [ ] Store bidirectional mapping
  - [ ] After `tl publish`: record `checkpoint_id -> jj_commit_id`
  - [ ] After `tl pull --import`: record `checkpoint_id -> jj_commit_id`
  - [ ] Use for `tl push` to determine what to push

- [ ] Query mapping
  - [ ] `get_jj_commit(checkpoint_id: CheckpointId) -> Option<jj_lib::backend::CommitId>`
  - [ ] `get_checkpoint(jj_commit_id: jj_lib::backend::CommitId) -> Option<CheckpointId>`

- [ ] Persist to `.tl/state/jj-mapping.db`

## JJ Workspace Initialization (Helper)

- [ ] Implement `init_jj.rs`: JJ workspace setup helper
  - [ ] `tl jj-init` command (optional)
  - [ ] Runs `jj git init` if not already initialized
  - [ ] Sets up recommended JJ config for seer integration

- [ ] Recommended JJ config
  ```toml
  # .jj/config.toml
  [git]
  auto-local-bookmark = false  # Don't auto-create bookmarks
  push-bookmark-prefix = "snap/"  # Namespace seer bookmarks
  ```

- [ ] **MVP decision**: User runs `jj git init` manually
  - [ ] We don't create JJ workspace (less coupling)
  - [ ] User's responsibility to set up JJ

## Error Handling

- [ ] JJ not available
  - [ ] Check if `jj` binary exists in PATH
  - [ ] If not: error with installation instructions
    ```
    Error: JJ not found. Install with:
      cargo install jj-cli
    ```

- [ ] JJ workspace not initialized
  - [ ] Detect: no `.jj/` directory
  - [ ] Error: "Run `jj git init` to initialize JJ workspace"

- [ ] JJ push conflicts
  - [ ] Detect: push rejected by remote
  - [ ] Error: "Push failed. Run `jj git fetch` and rebase."

## Testing

- [ ] Unit tests for materialization
  - [ ] Create checkpoint → materialize to temp dir → verify files
  - [ ] Test commit message formatting

- [ ] Integration tests with JJ
  - [ ] Requires `jj` binary installed (skip if not found)
  - [ ] Test: `tl publish` → `jj log` (verify commit created)
  - [ ] Test: `tl push` → verify Git remote updated
  - [ ] Test: `tl pull --import` → verify checkpoint created

- [ ] Mock JJ for unit tests
  - [ ] Mock `jj-lib` calls (avoid real JJ workspace)
  - [ ] Test mapping persistence

## Performance Optimization

- [ ] Lazy JJ workspace detection
  - [ ] Only check for `.jj/` when JJ commands are used
  - [ ] Don't slow down non-JJ operations

- [ ] Efficient tree export
  - [ ] Use hardlinks when possible (instead of copying)
  - [ ] Temp directory: use same filesystem as repo (enables hardlinks)

- [ ] Checkpoint range compaction
  - [ ] Default: compact to single commit (faster)
  - [ ] Option: expand for detailed history (slower)

## Documentation

- [ ] Document JJ integration workflow
  ```markdown
  ## Using Seer with JJ

  1. Initialize JJ in your repo:
     ```
     jj git init
     ```

  2. Make changes, seer creates checkpoints automatically

  3. Publish checkpoint to JJ:
     ```
     snap publish HEAD -b my-feature
     ```

  4. Push to Git remote:
     ```
     snap push my-feature
     ```

  5. Pull changes:
     ```
     snap pull --import
     ```
  ```

- [ ] Document checkpoint vs JJ commit philosophy
  - [ ] Checkpoints: high-frequency, local, fine-grained
  - [ ] JJ commits: low-frequency, publishable, coarse-grained
  - [ ] Best practice: create JJ commits at milestones

## Future Enhancements (Post-MVP)

- [ ] Auto-publish on milestone events
  - [ ] Hook: publish checkpoint when tests pass
  - [ ] Hook: publish before `git push`

- [ ] Bidirectional sync
  - [ ] Detect JJ commits created outside seer
  - [ ] Auto-import as checkpoints (with config flag)

- [ ] Conflict resolution UI
  - [ ] When `tl pull` conflicts with local changes
  - [ ] Show diff, let user choose resolution

- [ ] Bookmark management
  - [ ] `tl jj-bookmarks` to list all snap/* bookmarks
  - [ ] `tl jj-cleanup` to remove old bookmarks

## Success Criteria

- [ ] User can publish checkpoint to JJ
- [ ] User can push JJ bookmark to Git remote
- [ ] User can pull from Git remote and import to seer
- [ ] Mapping persists across restarts
- [ ] Works with or without JJ (degrades gracefully)
- [ ] No performance impact on non-JJ users
