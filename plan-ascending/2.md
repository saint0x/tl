# Phase 2: File System Watcher

## Platform Abstraction Layer

- [ ] Create `crates/watcher/Cargo.toml`
  - [ ] Dependencies: notify, tokio, crossbeam-channel, dashmap, parking_lot, tracing
  - [ ] Add core as workspace dependency

- [ ] Define platform-agnostic watcher trait
  - [ ] `crates/watcher/src/platform/mod.rs`
  ```rust
  pub trait FileWatcher: Send + Sync {
      async fn watch(&mut self, path: PathBuf) -> Result<()>;
      async fn unwatch(&mut self, path: &Path) -> Result<()>;
      async fn next_event(&mut self) -> Option<WatchEvent>;
      fn is_overflow(&self) -> bool;
  }
  ```

- [ ] Define `WatchEvent` enum
  ```rust
  pub enum WatchEvent {
      Modified(Arc<Path>),
      Created(Arc<Path>),
      Deleted(Arc<Path>),
      Renamed { from: Arc<Path>, to: Arc<Path> },
      Overflow,
  }
  ```
  - [ ] Use `Arc<Path>` for path interning (share across events)

## macOS Implementation (FSEvents)

- [ ] Implement `platform/macos.rs`
  - [ ] `struct MacOSWatcher` wrapping `notify::RecommendedWatcher`
  - [ ] Configure FSEvents with:
    - [ ] File-level granularity (not directory-level)
    - [ ] No defer flag (immediate events)
    - [ ] Latency: 50ms (low latency)
  - [ ] Implement `FileWatcher` trait
  - [ ] Handle FSEvents overflow detection
  - [ ] Convert FSEvents to `WatchEvent` enum

- [ ] Handle atomic save patterns (macOS specific)
  - [ ] Detect TextEdit/Vim patterns: write to temp, rename to target
  - [ ] Coalesce rename events into single modify

## Linux Implementation (inotify)

- [ ] Implement `platform/linux.rs`
  - [ ] `struct LinuxWatcher` wrapping `notify::InotifyWatcher`
  - [ ] Configure inotify with:
    - [ ] Events: MODIFY, CREATE, DELETE, MOVED_FROM, MOVED_TO
    - [ ] Watch flags: DONT_FOLLOW (don't follow symlinks)
  - [ ] Implement `FileWatcher` trait
  - [ ] Handle inotify queue overflow (event loss detection)
  - [ ] Convert inotify events to `WatchEvent` enum

- [ ] Handle atomic save patterns (Linux specific)
  - [ ] Detect typical patterns: `.swp` files, `.tmp` renames
  - [ ] Coalesce MOVED_FROM + MOVED_TO into rename event

## Compile-Time Platform Selection

- [ ] Update `platform/mod.rs` with conditional compilation
  ```rust
  #[cfg(target_os = "macos")]
  pub use macos::MacOSWatcher as PlatformWatcher;

  #[cfg(target_os = "linux")]
  pub use linux::LinuxWatcher as PlatformWatcher;
  ```

- [ ] Add feature flags in `watcher/Cargo.toml`
  - [ ] Default features: platform-specific

## Debouncing Engine

- [ ] Implement `debounce.rs`: Per-path debouncing
  - [ ] Fixed-size ring buffer for events (8192 entries, pre-allocated)
  ```rust
  struct EventBuffer {
      buffer: ArrayQueue<WatchEvent>,  // capacity: 8192
      dropped_count: AtomicU64,
  }
  ```
  - [ ] Pre-allocate on startup (zero runtime allocation)
  - [ ] Track dropped events when buffer overflows

- [ ] Implement `Debouncer`
  ```rust
  struct Debouncer {
      event_rx: Receiver<WatchEvent>,
      debounce_map: DashMap<PathBuf, DebounceEntry>,
      debounce_duration: Duration,  // default 300ms, configurable
      output_tx: Sender<Vec<PathBuf>>,  // batched output
  }

  struct DebounceEntry {
      last_event: Instant,
      timer_handle: Option<JoinHandle<()>>,
  }
  ```

- [ ] Implement debounce algorithm
  - [ ] On event for path P:
    - [ ] Check if P already has pending timer
    - [ ] If yes: reset timer (extend debounce window)
    - [ ] If no: create new timer for `debounce_duration`
  - [ ] On timer expiry:
    - [ ] Emit path to output channel
    - [ ] Remove from debounce_map
  - [ ] Use tokio timers for async debouncing

- [ ] Implement batch emission
  - [ ] Collect debounced paths into batches
  - [ ] Emit batch every 100ms or when 100 paths accumulated
  - [ ] Reduce syscall overhead

## Event Coalescing

- [ ] Implement `coalesce.rs`: Event deduplication
  - [ ] `coalesce_events(events: Vec<WatchEvent>) -> Vec<WatchEvent>`
  - [ ] Merge multiple events for same path:
    - [ ] Multiple `Modified` → single `Modified`
    - [ ] `Created` + `Modified` → `Created`
    - [ ] `Created` + `Deleted` → (cancel out, no event)
    - [ ] `Deleted` + `Created` → `Modified` (file recreated)

- [ ] Detect atomic save patterns
  - [ ] Pattern: `Renamed { from: ".file.tmp", to: "file" }`
  - [ ] Emit as: `Modified("file")`
  - [ ] Common patterns:
    - [ ] Vim: `.file.swp` → `file`
    - [ ] TextEdit: `file.tmp` → `file`
    - [ ] IDE: `file~` → `file`

- [ ] Implement rename detection
  - [ ] Track `Renamed` events in same batch
  - [ ] If blob hash matches: tag as rename (for UI)
  - [ ] Don't bake into storage (presentation layer only)

## Overflow Recovery

- [ ] Implement `overflow.rs`: Targeted rescan
  - [ ] Detect overflow conditions:
    - [ ] `WatchEvent::Overflow` from platform watcher
    - [ ] Event buffer full (dropped events > threshold)

- [ ] Implement targeted rescan algorithm
  - [ ] **Do NOT full repo scan** (critical!)
  - [ ] Use mtime/size heuristics:
    ```rust
    fn targeted_rescan(
        last_checkpoint_time: Instant,
        last_pathmap: &PathMap,
    ) -> Result<Vec<PathBuf>> {
        // Walk filesystem, check only mtime > last_checkpoint_time
        // Compare size/mtime against last_pathmap
        // Return candidate changed paths
    }
    ```
  - [ ] Walk only modified directories (use parent mtimes)
  - [ ] Limit rescan to recently active areas (heuristic)

- [ ] Implement graceful degradation
  - [ ] Mark repo state as "dirty_unknown" during rescan
  - [ ] Pause watcher temporarily
  - [ ] Resume normal operation after reconciliation

## Watcher Main Loop

- [ ] Implement `watcher.rs`: Main watcher coordinator
  ```rust
  pub struct Watcher {
      platform_watcher: Box<dyn FileWatcher>,
      event_buffer: EventBuffer,
      debouncer: Debouncer,
      repo_root: PathBuf,
  }
  ```

- [ ] Implement `run()` main loop
  - [ ] Spawn platform watcher in background task
  - [ ] Receive events into ring buffer
  - [ ] Feed events to debouncer
  - [ ] Receive debounced batches
  - [ ] Apply coalescing
  - [ ] Emit final batch to checkpoint engine

- [ ] Implement overflow handling
  - [ ] Monitor buffer fill level
  - [ ] Trigger targeted rescan if threshold exceeded
  - [ ] Log metrics: events/sec, buffer usage, drop rate

## Path Interning

- [ ] Implement `path_intern.rs`: Path deduplication
  ```rust
  pub struct PathInterner {
      paths: DashMap<PathBuf, Arc<Path>>,
  }
  ```
  - [ ] `intern(&mut self, path: PathBuf) -> Arc<Path>`
  - [ ] Return existing `Arc<Path>` if already interned
  - [ ] Single allocation per unique path across all events
  - [ ] Memory savings: 1000s of events × path length

## Configuration

- [ ] Implement `config.rs`: Watcher configuration
  ```rust
  pub struct WatcherConfig {
      pub debounce_duration: Duration,     // default: 300ms
      pub batch_size: usize,               // default: 100 paths
      pub batch_timeout: Duration,         // default: 100ms
      pub buffer_size: usize,              // default: 8192 events
      pub rescan_threshold: usize,         // default: 1000 dropped events
  }
  ```
  - [ ] Load from `.tl/config.toml`
  - [ ] Sensible defaults for MVP

## Testing

- [ ] Unit tests for debouncing
  - [ ] Test single path debounce (multiple events → single output)
  - [ ] Test per-path independence (path A, path B debounce separately)
  - [ ] Test timer reset on new event

- [ ] Unit tests for coalescing
  - [ ] Test event deduplication
  - [ ] Test atomic save pattern detection
  - [ ] Test create+delete cancellation

- [ ] Unit tests for overflow recovery
  - [ ] Mock overflow condition
  - [ ] Test targeted rescan logic
  - [ ] Verify no full repo scan

- [ ] Integration tests (with real filesystem)
  - [ ] Create temp directory, trigger events
  - [ ] Verify debounced output
  - [ ] Test rapid file changes (stress test)
  - [ ] Test atomic saves (create `.tmp`, rename)

## Memory Profiling

- [ ] Benchmark watcher memory usage
  - [ ] Idle state: < 5MB
  - [ ] Under load (1000 events/sec): < 20MB
  - [ ] Verify ring buffer pre-allocation (no runtime malloc)
  - [ ] Verify path interning effectiveness

- [ ] Benchmark watcher latency
  - [ ] File change → debounced output: < 500ms (with 300ms debounce)
  - [ ] Event processing throughput: > 10k events/sec

## Platform-Specific Edge Cases

- [ ] macOS-specific handling
  - [ ] Test FSEvents latency (verify 50ms setting works)
  - [ ] Test `.DS_Store` exclusion
  - [ ] Test Spotlight indexing interference

- [ ] Linux-specific handling
  - [ ] Test inotify watch limit (default 8192)
  - [ ] Handle "too many open files" gracefully
  - [ ] Test systemd integration (optional)
